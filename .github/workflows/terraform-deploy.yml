name: Customer API Deploy

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.13.3
  EKS_CLUSTER_NAME: eks-tc4-lanchonete-customer-v1

jobs:
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    defaults:
      run:
        working-directory: ./terraform
    env:
      TF_VAR_mongo_user: ${{ secrets.MONGO_USER }}
      TF_VAR_mongo_password: ${{ secrets.MONGO_PASSWORD }}
      TF_VAR_mongo_db_name: ${{ secrets.MONGO_DB_NAME }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
          kubectl get nodes

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: terraform plan -no-color

  terraform-apply:
    name: Customer API Deploy
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply'
    defaults:
      run:
        working-directory: ./terraform
    env:
      TF_VAR_mongo_user: ${{ secrets.MONGO_USER }}
      TF_VAR_mongo_password: ${{ secrets.MONGO_PASSWORD }}
      TF_VAR_mongo_db_name: ${{ secrets.MONGO_DB_NAME }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
          kubectl get nodes

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan

      - name: Verify MongoDB Deployment
        run: |
          echo "Waiting for MongoDB pod to be ready..."
          kubectl wait --for=condition=ready pod -l app=mongodb -n tc4-customer --timeout=300s || true
          kubectl get pods -n tc4-customer -l app=mongodb

      - name: Verify API Deployment
        run: |
          echo "Waiting for API pod to be ready..."
          kubectl wait --for=condition=ready pod -l app=tc4-customer-api -n tc4-customer --timeout=300s
          kubectl get pods -n tc4-customer
          kubectl get services -n tc4-customer

      - name: Get LoadBalancer URL
        id: get-url
        run: |
          echo "Waiting for LoadBalancer to get external IP..."
          sleep 60
          LB_HOSTNAME=$(kubectl get svc api-service -n tc4-customer -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ -n "$LB_HOSTNAME" ]; then
            echo "loadbalancer-url=http://$LB_HOSTNAME" >> $GITHUB_OUTPUT
            echo "LoadBalancer URL: http://$LB_HOSTNAME"
          else
            echo "LoadBalancer still provisioning..."
            echo "loadbalancer-url=pending" >> $GITHUB_OUTPUT
          fi

      - name: Health Check
        if: steps.get-url.outputs.loadbalancer-url != 'pending'
        run: |
          URL="${{ steps.get-url.outputs.loadbalancer-url }}/health"
          echo "Testing health endpoint: $URL"
          for i in {1..5}; do
            if curl -f $URL; then
              echo "Health check passed!"
              break
            else
              echo "Attempt $i failed, retrying in 30s..."
              sleep 30
            fi
          done

      - name: Output API Info
        run: |
          echo "Customer API deployed successfully!"
          echo "Namespace: tc4-customer"
          echo "Service: api-service"
          echo "LoadBalancer: ${{ steps.get-url.outputs.loadbalancer-url }}"

  terraform-destroy:
    name: Customer API Destroy
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    defaults:
      run:
        working-directory: ./terraform
    env:
      TF_VAR_mongo_user: ${{ secrets.MONGO_USER }}
      TF_VAR_mongo_password: ${{ secrets.MONGO_PASSWORD }}
      TF_VAR_mongo_db_name: ${{ secrets.MONGO_DB_NAME }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Check if EKS cluster exists
        id: check-cluster
        run: |
          if aws eks describe-cluster --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} &> /dev/null; then
            echo "cluster-exists=true" >> $GITHUB_OUTPUT
            echo "EKS cluster exists, configuring kubectl..."
          else
            echo "cluster-exists=false" >> $GITHUB_OUTPUT
            echo "EKS cluster not found, skipping kubectl configuration"
          fi

      - name: Configure kubectl
        if: steps.check-cluster.outputs.cluster-exists == 'true'
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
          kubectl get nodes || echo "Failed to get nodes, but continuing..."

      - name: Terraform Init
        run: terraform init

      - name: Check Terraform State
        id: check-state
        run: |
          if terraform state list &> /dev/null; then
            echo "state-exists=true" >> $GITHUB_OUTPUT
            echo "Terraform state found"
          else
            echo "state-exists=false" >> $GITHUB_OUTPUT
            echo "No Terraform state found"
          fi

      - name: Terraform Plan Destroy
        if: steps.check-state.outputs.state-exists == 'true'
        run: terraform plan -destroy -no-color
        continue-on-error: true

      - name: Terraform Destroy
        if: steps.check-state.outputs.state-exists == 'true'
        run: |
          echo "Destroying Customer API infrastructure..."
          terraform destroy -auto-approve

      - name: Verify Destruction
        run: |
          echo "Verifying resource destruction..."
          if [ "${{ steps.check-cluster.outputs.cluster-exists }}" == "true" ]; then
            kubectl get pods -n tc4-customer 2>/dev/null || echo "Namespace tc4-customer destroyed or not found"
          fi
          echo "Customer API destroy job completed"
